---
title: Cell Rendering
subtitle: Learn how to customize cell rendering
---

### Basic Cell Rendering

By default, Svelte Table will render the cell content as a string. The value of the cell is generated by the `accessorKey` of the column and the data item.

Here's an example with a `User` type:

```ts
type User = {
	id: number;
	name: string;
	age: number;
};

const columns: Column<User>[] = [
	{ id: 'id', accessorKey: 'id', label: 'ID' },
	{ id: 'name', accessorKey: 'name', label: 'Name' },
	{ id: 'age', accessorKey: 'age', label: 'Age' },
	{ id: 'action', label: '' }
];

const data: User[] = [
	{ id: 1, name: 'Alice', age: 25 },
	{ id: 2, name: 'Bob', age: 30 }
];
```

In this example the `accessorKey` is used as the property name to access the data item. The cell content will be rendered as a string. 'accessorKey' is optional, if not provided, the resulting cell value will be an empty string. To access the value of the cell, you do it in this way:

```svelte
<table>
	<thead>
		<tr>
			{#each table.headers as header}
				<th>{header}</th>
			{/each}
		</tr>
	</thead>
	<tbody>
		{#each table.rows as row}
			<tr>
				{#each row.cells as cell}
					<td>{cell.value}</td> <!-- cell.value is the value of the cell based on the accessorKey -->
				{/each}
			</tr>
		{/each}
	</tbody>
</table>
```

### Custom Cell Rendering

Svelte table does not enforce any specific way to render the cell content. You can do whatever you want! For example, you can render a button in a cell with a given column id:

```svelte
<table>
	<thead>
		<tr>
			{#each table.headers as header}
				<th>{header}</th>
			{/each}
		</tr>
	</thead>
	<tbody>
		{#each table.rows as row}
			<tr>
				{#each row.cells as cell}
					<td>
						{#if cell.columnId === 'action'}
							<button onclick={() => console.log('clicked')}>Click me</button>
						{:else}
							{cell.value}
						{/if}
					</td>
				{/each}
			</tr>
		{/each}
	</tbody>
</table>
```

In this example, we check if the `columnId` of the cell is `action`. If it is, we render a button with an `onclick` event. Otherwise, we render the cell value as a string.

### Cell Rendering with Components

You can also use components to render the cell content. This is useful when you want to render complex content in the cell. For example, you can render a custom component in a cell with a given column id:

```svelte
<script>
	import Button from './Button.svelte';
</script>

<table>
	<thead>
		<tr>
			{#each table.headers as header}
				<th>{header}</th>
			{/each}
		</tr>
	</thead>
	<tbody>
		{#each table.rows as row}
			<tr>
				{#each row.cells as cell}
					<td>
						{#if cell.columnId === 'action'}
							<Button onClick={() => console.log("Clicked user", cell.item.name)} />
						{:else}
							{cell.value}
						{/if}
					</td>
				{/each}
			</tr>
		{/each}
	</tbody>
</table>
```

In this example, we import a `Button` component and render it in the cell with the `columnId` of `action`. Otherwise, we render the cell value as a string.

### Cell Rendering with Svelte Snippets

To make html template more readable and maintainable, you can use Svelte 5's powerful snippet feature to render the cell content. This is useful when you want to render dynamic content in the cell. So following the previous example, you can extract the button into a snippet:

```svelte
<script>
</script>

{#snippet Button(cell: Cell<User>)}
	<button onclick={() => console.log('clicked user', cell.item.name)}>Click me</button>
{/snippet}

<table>
	<thead>
		<tr>
			{#each table.headers as header}
				<th>{header}</th>
			{/each}
		</tr>
	</thead>
	<tbody>
		{#each table.rows as row}
			<tr>
				{#each row.cells as cell}
					<td>
						{#if cell.columnId === 'action'}
							{@render Button(cell)}
						{:else}
							{cell.value}
						{/if}
					</td>
				{/each}
			</tr>
		{/each}
	</tbody>
</table>
```

You can also render a component inside a snippet. You can take advantage of Svelte 5 powerful features to render dynamic content in the cell.

When you have a lot of custom cell rendering logic, it's a good idea to extract the logic into a separate component or snippet. This will make your code more maintainable and easier to read. For example let's assume you have a lot of columns and you want to render a different component for each column. The basic approach would look like something like this:

```svelte
<script>
	import Button from './Button.svelte';
	import Checkbox from './Checkbox.svelte';
	import Chip from './Chip.svelte';
</script>

<table>
	<thead>
		<tr>
			{#each table.headers as header}
				<th>{header}</th>
			{/each}
		</tr>
	</thead>
	<tbody>
		{#each table.rows as row}
			<tr>
				{#each row.cells as cell}
					<td>
						{#if cell.columnId === 'action'}
							<Button />
						{:else if cell.columnId === 'checkbox'}
							<Checkbox />
						{:else if cell.columnId === 'chip'}
							<Chip />
						{:else}
							{cell.value}
						{/if}
					</td>
				{/each}
			</tr>
		{/each}
	</tbody>
</table>
```

This approach works, but it can get messy and hard to maintain as you add more columns. A better approach is to extract the custom cell rendering logic into a separate component or snippet. This will make your code more maintainable and easier to read. Here's an example of how you can do this:

```svelte
<script>
  import Button from './Button.svelte';
  import Checkbox from './Checkbox.svelte';
  import Chip from './Chip.svelte';

</script>

{#snippet Cell(cell: Cell<User>)}
  {#if cell.columnId === 'action'}
    <Button />
  {:else if cell.columnId === 'checkbox'}
    <Checkbox />
  {:else if cell.columnId === 'chip'}
    <Chip />
  {:else}
    {cell.value}
  {/if}
{/snippet}

<table>
	<thead>
		<tr>
			{#each table.headers as header}
				<th>{header}</th>
			{/each}
		</tr>
	</thead>
	<tbody>
		{#each table.rows as row}
			<tr>
				{#each row.cells as cell}
					<td>{@render Cell(cell)}</td>
				{/each}
			</tr>
		{/each}
	</tbody>
</table>
```

In this example, we extract the custom cell rendering logic into a separate snippet called `Cell`. This snippet takes a `cell` object as a parameter and renders the appropriate component based on the `columnId` of the cell. This makes the code more maintainable and easier to read, especially as you add more columns to your table.
